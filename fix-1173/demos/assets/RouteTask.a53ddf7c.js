import{cQ as g,v as A,C as h,e as $,i as v,cR as R}from"./main.f21fb970.js";import{u,d as w,b as N,p as k,f as S,o as T}from"./networkService.870e11c6.js";import"./GPMessage.89f2b59f.js";const j=T({accumulateAttributes:{name:"accumulateAttributeNames"},attributeParameterValues:!0,directionsTimeAttribute:{name:"directionsTimeAttributeName"},impedanceAttribute:{name:"impedanceAttributeName"},outSpatialReference:{name:"outSR",getter:t=>t.outSpatialReference.wkid},pointBarriers:{name:"barriers"},polylineBarriers:!0,polygonBarriers:!0,restrictionAttributes:{name:"restrictionAttributeNames"},stops:!0,travelMode:!0});async function q(t,e,f){const p=[],a=[],s={},i={},m=g(t),{path:o}=m;e.stops&&e.stops.features&&u(e.stops.features,a,"stops.features",s),e.pointBarriers&&e.pointBarriers.features&&u(e.pointBarriers.features,a,"pointBarriers.features",s),e.polylineBarriers&&e.polylineBarriers.features&&u(e.polylineBarriers.features,a,"polylineBarriers.features",s),e.polygonBarriers&&e.polygonBarriers.features&&u(e.polygonBarriers.features,a,"polygonBarriers.features",s);const l=await A(a);for(const r in s){const n=s[r];p.push(r),i[r]=l.slice(n[0],n[1])}if(w(i,p)){let r=null;try{r=await N(o,e.apiKey,f)}catch{}r&&!r.hasZ&&k(i,p)}for(const r in i)i[r].forEach((n,d)=>{e.get(r)[d].geometry=n});const y={...f,query:{...m.query,...j.toQueryParams(e),f:"json"}},B=o.endsWith("/solve")?o:`${o}/solve`,b=await h(B,y);return S(b)}let c=class extends R{constructor(t){super(t)}solve(t,e){return q(this.url,t,e)}};c=$([v("esri.tasks.RouteTask")],c);const C=c;export{C as default};
